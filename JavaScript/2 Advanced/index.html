<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<style>
    ul, li {
        list-style-type: circle;
    }

    .box{
        padding-bottom: 500px;
    }

    button{
        padding: 4px 8px;
        margin-top: 10px;
        margin-bottom: 10px;
        cursor: pointer;
    }

    #root{
        border: 1px solid;
        border-radius: 8px;
        min-height: 200px;
        padding-top: 10px;
    }
</style>
<body>
    <div class="box">
        <h2>Chương I - 1. IIFE là gì?</h2>
        <div>
            <ul>
                <li>là 1 func duy nhất giống constructor</li>
                <li>được hiểu là (() => {})() </li>
                <li>trước iife thì phải có dấu `;` </li>
                <li>là func private </li>
                <li>sử dụng khi muốn code chạy ngay nhma k ảnh hưởng đến phạm vi bên ngoài (vd để tạo 1 lib) </li>
            </ul>
        </div>
    
        <h2>2. Scope là gì?</h2>
        <div>
            <ul>
                <li>Phạm vi biến: Global, Code Block, Local Scope</li>
            </ul>
        </div>
        
        <h2>3. Khái niệm Closure?</h2>
        <div>
            <ul>
                <li>là 1 hàm có thể ghi nhớ nơi nó được tạo ra & truy cập đc biến ở bên ngoài phạm vi của nó</li>
            </ul>
        </div>
        
        <h2>Chương II - 4. Hoisting là gì??</h2>
        <div>
            <ul>
                <li>Khai báo bằng var, let, const, declaration function đều được hoisting. || Nhưng dòng lệnh Truy cập Biến or Hàm nằm Trên dòng Khai báo thì xảy ra 2 trường hợp:</li>
                <li>Var, Declaration function được gán value là Undefined or NULL => Nên kh có lỗi</li>
                <li>Let, Const không được gán value, mà được đưa vào Temporal Dead Zone (vùng kh truy cập được) => Nên có lỗi xuất hiện</li>
            </ul>
        </div>
            
        <h2>5. Strict mode?</h2>
        <div>
            <ul>
                <li>Khi sử dụng `Strict mode?` giúp báo lỗi or ngăn chặn những doạn mã không an toàn hay dễ gây nhầm lẫn</li>
                <li>Báo lỗi khi gán lại giá trị cho thuộn tinh có `writable: false`</li>
                <li>Báo lỗi khi hàm có tham số cùng tên</li>
                <li>Khai báo hàm trong `code block` thì hàm sẽ thuộc phạm vi của `code block`</li>
                <li>Không đặt tên biến, tên hàm bằng một số từ khóa `nhạy cảm` cảu ngôn ngữ</li>
    
                <h4>Công dụng</h4>
                <ul>
                    <li>Tránh `quên` từ khóa khai báo biến</li>
                    <li>Tránh `trùng` tên biến dẫn tới lỗi logic</li>
                    <li>Sử dụng bộ nhớ hiệu quả vì tránh tạo biến global</li>
                </ul>
            </ul>
        </div>

        <h2>6. Primitive Types & Reference Types?</h2>
        <div>
            <ul>
                <li><img src="./img/Primitive Types_Reference Types.png" height="600px"> </li>
                <li>Value types: biến sẽ lưu giá trị & ô nhớ riêng biệt vì vậy khi thay đổi sẽ không ảnh hưởng đến nhau</li>
                <li>Reference types: biến sẽ lưu địa chỉ ô nhớ vì vậy khi thay đổi value thì các biến trỏ đến 1 địa chỉ cụ thể</li>
            </ul>
        </div>

        <h2>Chương III - 7. Từ khóa "this"?</h2>
        <div>
            <ul>
                <li>Từ khóa `this` trong js đề cập đến đối tượng mà nó thuộc về</li>
                <li>Trong một phương thức, `this` tham chiếu tới đối tượng truy cập phương thức (đối tượng trước dấu .)</li>
                <li>Đứng ngoài phương thức, `this` tham chiếu tới đối tượng `global`</li>
                <li><button>Click me now !</button></li>
                <li><button onclick="console.log(this)">Click me now2 !</button></li>
                <!-- ở button 2 vẫn in ra vì khi js build vẫn giống cách bắt event `this` ở đây chính là button.onclick -->
                
                <h4>Lưu ý</h4>
                <ul>
                    <li>`this` trong hàm tạo là đại diện cho đối tượng sẽ được tạo</li>
                    <li>`this` trong một hàm là `undefined` khi ở `strict mode`</li>
                    <li>Với arrow function thì k có `this` vậy nên khi dùng thì `this` sẽ là đối tượng bên ngoài gần nhất</li>
                    <li>Các phương thức bind(), call(), apply() có thể tham chiếu `this` tới đối tượng khác</li>
                </ul>
                
                <h4>Tóm tắt</h4>
                <ul>
                    <li>Phân biệt qua cách hàm/method được gọi. Được gọi qua object.method() thì this là object. Được gọi theo tenHam() thì this là window (strict mode là undefined). Mỗi hàm luôn có context riêng, hàm trong method cũng có context riêng của nó (trừ arrow function).</li>
                </ul>
            </ul>
        </div>

        <h2>8. Fn.bind() method - Phần 1</h2>
        <div>
            <ul>
                <li>Phương thức `bind()` sẽ trả về 1 hàm mới</li>
                <li>Có thể nhận các đối số như hàm ban đầu</li>
                <li><button id="btnBindMethod">Come to your mind...</button></li>
            </ul>
        </div>

        <h2>9. Fn.bind() method - Phần 2</h2>
        <div>
            <h2 class="title">welcome to my store</h2>
            <input type="text" id="input" placeholder="Enter car name...">
            <button id="submit">Add</button>

            <ul id="root"></ul>


            <span>==========================</span>
            <ul>
                <li>Sử dụng arrow func vì k có `Context` vì thế sẽ lấy từ ngoài nên k cần lưu biến `this` (_this=this)</li>
                <li>Delegation PARENT <a href="https://viblo.asia/p/event-delegation-in-javascript-V3m5WALEZO7" target="_blank">Event Delegation in JavaScript</a></li>
                <li>closest(): là phương thức của DOM Element giúp kiểm tra Element đó or PARENT Element có chứa class đó hay k?</li>
                <li>data-index => là 1 dataset trong DOM | data-name(đặt tên là gì thì đến lúc) => dataset.name | ở bài này là (Element.dataset.index)</li>
            </ul>
        </div>

        <h2>10. Fn.call() method</h2>
        <div>
            <ul>
                <li>Là phương thức trong prototype của Function constructor, phương thức này được dùng để gọi hàm và cũng có thể `bind this` cho hàm</li>
                <li>gọi hàm với `call` method</li>
                <li>gọi hàm và `bind this`, lưu ý trong `strict mode` vẫn có `this` nếu được `bind`</li>
                <li>thể hiện tính kế thừa (extends) trong OOP</li>
                <li>mượn hàm (function borrowing), ví dụ với `arguments`</li>
                <li>`bind()` vs `call()` => `call()` sau khi `bind` xong se goi ham, còn `bind()` chỉ `bind` chứ k gọi hàm</li>
                <li>Fn.call() giúp gọi hàm và bind this tới đối tượng khác, mặc định this là window object</li>
                <li>Fn.call() không trả ra hàm mới, nó gọi luôn hàm sau khi bind this (Fn.bind() thì chỉ bind this nhưng không gọi hàm)</li>
                <li>Fn.call() dùng để mượn hàm - function borrowing</li>
                <li>Fn.call() có thể dùng để kế thừa properties & method từ 1 Constructor khác</li>
            </ul>
        </div>









    </div>
    <!-- <script src="./index.js"></script> -->
    <!-- <script src="./index2.js"></script> -->
    <!-- <script src="./index3.js"></script> -->
    <!-- <script src="./index4.js"></script> -->
    <script src="./index5.js"></script>

</body>
</html>