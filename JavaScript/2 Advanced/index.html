<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSNC</title>
</head>
<style>
    ul, li {
        list-style-type: circle;
    }

    .box{
        padding-bottom: 500px;
    }

    button{
        padding: 4px 8px;
        margin-top: 10px;
        margin-bottom: 10px;
        cursor: pointer;
    }

    #root{
        border: 1px solid;
        border-radius: 8px;
        min-height: 200px;
        padding-top: 10px;
    }
</style>
<body>
    <div class="box">
        <h2>Chương I - 1. IIFE là gì?</h2>
        <div>
            <ul>
                <li>là 1 func duy nhất giống constructor</li>
                <li>được hiểu là (() => {})() </li>
                <li>trước iife thì phải có dấu `;` </li>
                <li>là func private </li>
                <li>sử dụng khi muốn code chạy ngay nhma k ảnh hưởng đến phạm vi bên ngoài (vd để tạo 1 lib) </li>
            </ul>
        </div>
    
        <h2>2. Scope là gì?</h2>
        <div>
            <ul>
                <li>Phạm vi biến: Global, Code Block, Local Scope</li>
            </ul>
        </div>
        
        <h2>3. Khái niệm Closure?</h2>
        <div>
            <ul>
                <li>là 1 hàm có thể ghi nhớ nơi nó được tạo ra & truy cập đc biến ở bên ngoài phạm vi của nó</li>
            </ul>
        </div>
        
        <h2>Chương II - 4. Hoisting là gì??</h2>
        <div>
            <ul>
                <li>Khai báo bằng var, let, const, declaration function đều được hoisting. || Nhưng dòng lệnh Truy cập Biến or Hàm nằm Trên dòng Khai báo thì xảy ra 2 trường hợp:</li>
                <li>Var, Declaration function được gán value là Undefined or NULL => Nên kh có lỗi</li>
                <li>Let, Const không được gán value, mà được đưa vào Temporal Dead Zone (vùng kh truy cập được) => Nên có lỗi xuất hiện</li>
            </ul>
        </div>
            
        <h2>5. Strict mode?</h2>
        <div>
            <ul>
                <li>Khi sử dụng `Strict mode?` giúp báo lỗi or ngăn chặn những doạn mã không an toàn hay dễ gây nhầm lẫn</li>
                <li>Báo lỗi khi gán lại giá trị cho thuộn tinh có `writable: false`</li>
                <li>Báo lỗi khi hàm có tham số cùng tên</li>
                <li>Khai báo hàm trong `code block` thì hàm sẽ thuộc phạm vi của `code block`</li>
                <li>Không đặt tên biến, tên hàm bằng một số từ khóa `nhạy cảm` cảu ngôn ngữ</li>
    
                <h4>Công dụng</h4>
                <ul>
                    <li>Tránh `quên` từ khóa khai báo biến</li>
                    <li>Tránh `trùng` tên biến dẫn tới lỗi logic</li>
                    <li>Sử dụng bộ nhớ hiệu quả vì tránh tạo biến global</li>
                </ul>
            </ul>
        </div>

        <h2>6. Primitive Types & Reference Types?</h2>
        <div>
            <ul>
                <li><img src="./img/Primitive Types_Reference Types.png" height="600px"> </li>
                <li>Value types: biến sẽ lưu giá trị & ô nhớ riêng biệt vì vậy khi thay đổi sẽ không ảnh hưởng đến nhau</li>
                <li>Reference types: biến sẽ lưu địa chỉ ô nhớ vì vậy khi thay đổi value thì các biến trỏ đến 1 địa chỉ cụ thể</li>
            </ul>
        </div>

        <h2>Chương III - 7. Từ khóa "this"?</h2>
        <div>
            <ul>
                <li>Từ khóa `this` trong js đề cập đến đối tượng mà nó thuộc về</li>
                <li>Trong một phương thức, `this` tham chiếu tới đối tượng truy cập phương thức (đối tượng trước dấu .)</li>
                <li>Đứng ngoài phương thức, `this` tham chiếu tới đối tượng `global`</li>
                <li><button>Click me now !</button></li>
                <li><button onclick="console.log(this)">Click me now2 !</button></li>
                <!-- ở button 2 vẫn in ra vì khi js build vẫn giống cách bắt event `this` ở đây chính là button.onclick -->
                
                <h4>Lưu ý</h4>
                <ul>
                    <li>`this` trong hàm tạo là đại diện cho đối tượng sẽ được tạo</li>
                    <li>`this` trong một hàm là `undefined` khi ở `strict mode`</li>
                    <li>Với arrow function thì k có `this` vậy nên khi dùng thì `this` sẽ là đối tượng bên ngoài gần nhất</li>
                    <li>Các phương thức bind(), call(), apply() có thể tham chiếu `this` tới đối tượng khác</li>
                </ul>
                
                <h4>Tóm tắt</h4>
                <ul>
                    <li>Phân biệt qua cách hàm/method được gọi. Được gọi qua object.method() thì this là object. Được gọi theo tenHam() thì this là window (strict mode là undefined). Mỗi hàm luôn có context riêng, hàm trong method cũng có context riêng của nó (trừ arrow function).</li>
                </ul>
            </ul>
        </div>

        <h2>8. Fn.bind() method - Phần 1</h2>
        <div>
            <ul>
                <li>Phương thức `bind()` sẽ trả về 1 hàm mới</li>
                <li>Có thể nhận các đối số như hàm ban đầu</li>
                <li><button id="btnBindMethod">Come to your mind...</button></li>
            </ul>
        </div>

        <h2>9. Fn.bind() method - Phần 2</h2>
        <div>
            <h2 class="title">welcome to my store</h2>
            <input type="text" id="input" placeholder="Enter car name...">
            <button id="submit">Add</button>

            <ul id="root"></ul>


            <span>==========================</span>
            <ul>
                <li>Sử dụng arrow func vì k có `Context` vì thế sẽ lấy từ ngoài nên k cần lưu biến `this` (_this=this)</li>
                <li>Delegation PARENT <a href="https://viblo.asia/p/event-delegation-in-javascript-V3m5WALEZO7" target="_blank">Event Delegation in JavaScript</a></li>
                <li>closest(): là phương thức của DOM Element giúp kiểm tra Element đó or PARENT Element có chứa class đó hay k?</li>
                <li>data-index => là 1 dataset trong DOM | data-name(đặt tên là gì thì đến lúc) => dataset.name | ở bài này là (Element.dataset.index)</li>
            </ul>
        </div>

        <h2>10. Fn.call() method</h2>
        <div>
            <ul>
                <li>Là phương thức trong prototype của Function constructor, phương thức này được dùng để gọi hàm và cũng có thể `bind this` cho hàm</li>
                <li>gọi hàm với `call` method</li>
                <li>gọi hàm và `bind this`, lưu ý trong `strict mode` vẫn có `this` nếu được `bind`</li>
                <li>thể hiện tính kế thừa (extends) trong OOP</li>
                <li>mượn hàm (function borrowing), ví dụ với `arguments`</li>
                <li>`bind()` vs `call()` => `call()` sau khi `bind` xong se goi ham, còn `bind()` chỉ `bind` chứ k gọi hàm</li>
                <li>Fn.call() giúp gọi hàm và bind this tới đối tượng khác, mặc định this là window object</li>
                <li>Fn.call() không trả ra hàm mới, nó gọi luôn hàm sau khi bind this (Fn.bind() thì chỉ bind this nhưng không gọi hàm)</li>
                <li>Fn.call() dùng để mượn hàm - function borrowing</li>
                <li>Fn.call() có thể dùng để kế thừa properties & method từ 1 Constructor khác</li>
            </ul>
        </div>

        <h2>11. Fn.apply() method</h2>
        <div>
            <ul>
                <li>Phương thức này cho phép gọi một hàm với một `this` (bind) vàn truyền đối số cho hàm gốc dưới dạng mảng</li>
                
                <h4>So sánh: bind, call, apply</h4>
                <h5>Giống nhau</h5>
                <ul>
                    <li>- Cú pháp truy cập</li>
                    <li><code>function fn(){}</code></li>
                    <li><code>fn.bind()</code></li>
                    <li><code>fn.call()</code></li>
                    <li><code>fn.apply()</code></li>
                    <br>
                    <li>- Là các methods được thừa kế từ Function.prototype </li>
                    <li><code>function fn(){}</code></li>
                    
                    <li><code>fn.bind === Function.prototype.bind //true</code></li>
                    <li><code>fn.call === Function.prototype.call //true</code></li>
                    <li><code>fn.apply === Function.prototype.apply //true</code></li>
                </ul>


                <h5>Khác nhau</h5>
                <ul>
                    <li><code>function fn(){}</code></li>
                    <br>
                    <li>- Các đối số & cách hoạt động</li>
                    <li>Bind method</li>
                    <li>+ trả ra hàm mới với `this` tham chiếu tới `thisArg`</li>
                    <li>+ không thực hiện gọi hàm</li>
                    <li>+ nếu được `bind` kèm `arg1, arg2, ...` thì các đối số này được ưu tiên hơn</li>
                    <li><code>newFn = fn.bind(thisArg, arg1, arg2, ...)</code></li>
                    <li><code>newFn(arg1, arg2, ...)</code></li>
                    <br>
                    
                    <li>Call method</li>
                    <li>+ thực hiện bind `this` với `thisArg` và thực hiện gọi hàm</li>
                    <li>+ nhận các đối số cho hàm gốc từ `arg1, arg2, ...`</li>
                    <li><code>fn.call(thisArg, arg1, arg2, ...)</code></li>
                    <br>

                    <li>Apply method</li>
                    <li>+ thực hiện bind `this` với `thisArg` và thực hiện gọi hàm</li>
                    <li>+ nhận các đối số cho hàm gốc bằng đối số thứ 2 dưới dạng mảng [`arg1, arg2, ...`]</li>
                    <li><code>fn.apply(thisArg, [arg1, arg2, ...])</code></li>
                </ul>
            </ul>
        </div>


        <h2>12. Tìm hiểu về thư viện Redux</h2>
        <div>
            <ul>
                <li>redux data flow diagram</li>
                <li><img src="./img/reduxdataflowdiagram.gif" height="600px"> </li>
                <li>npm redux (<a href="https://www.npmjs.com/package/redux">npm redux docs</a>)</li>
                <li>skypack redux (<a href="https://www.skypack.dev/view/react-redux">react-redux docs</a>)</li>
                <li>
                    <code>import reactRedux from 'https://cdn.skypack.dev/redux';</code>
                </li>
            </ul>

            <fieldset>
                <legend>REDUX BANKING APP</legend>
                <div class="redux-banking-app">
                    <h2>Available balance: $<span id="output"></span></h2>
                    <button id="deposit">Deposit $10</button>
                    <button id="withdraw">Withdraw $10</button>
                </div>
            </fieldset>

        </div>


        <h2>13. Tự code thư viện build UI</h2>
        <div>
            <ul>
                <li><img src="./img/react-redux.png" width="600px"></li>
                <li>View: thành phần hiển thị giao diện người dùng trên ứng dụng, giao diện UI</li>
                <li>Actions: mô tả hành động (ví dụ: `thêm` thì làm gì? `sửa` thì làm gì? `xóa` thì làm gì?)</li>
                <li>*Khi `View` thực hiện `dispatch` 1 hành động (khi user thực hiện 1 hành động trên view) khi đó `View` trỏ sang `Actions` lấy (mô tả hành động)</li>
                <li>- Ví dụ user click nút `Thêm` thì `dispatch` trỏ sang `actions` và lấy `actions - thêm` lấy đc mô tả `thêm` thì sẽ làm gì? và đẩy sang `reducers`</li>
                <li>Reducers: luôn có giá trị ban đầu (giá trị khởi tạo) và từ lần thứ 2 sử dụng `reducers` thì sẽ nhận giá trị trả về trước đó để làm đối số đầu vào của lần sau sử dụng `reducers`</li>
                <li>* `reducers` nhận mô tả actions (ví dụ `thêm` thì làm gì?) và thực hiện ở bên trong & trả về dữ liệu mới vào `store` (ví dụ thêm 1 bài hát: `reducers` thêm mô tả bài hát và đẩy để lưu vào object store => store(update) => view cũng đc update)</li>
                <li>* Ví dụ thao tác xóa: `View` (user bấm nút xóa) == action xóa (dispatch) ==> Actions (lấy đc mô tả - như là xóa thì làm gì? gỡ bỏ 1 phần tử khỏi mảng) == đẩy sang reducers ==> Reducers (nhận được tín hiệu và phân biệt đc đây là hành động xóa và thực hiện xóa - gỡ 1 phần tử khỏi mảng) == update lại store là mất đi 1 phần tử ==> Store (khi store được update thì sẽ update lại cho View) ==> View (render lại -> re-render và thấy mất 1 phần tử trong mảng)</li>
                <li>Store: lưu trữ các hành động mà `reducers` trả về và update lại và chuyển dữ liệu đó cho `View`</li>
                
                <li><h3>Kiến thức liên quan </h3></li>
                <li>Tagged template literals: (tagFunction) <a href="https://viblo.asia/p/tim-hieu-ve-template-literals-trong-javascript-XL6lA9MDlek" target="_blank">Tìm hiểu về Template Literals trong JavaScript</a> | <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" target="_blank">Template literals (Template strings)</a></li>
                <li>Destructuring</li>
                <li>Array - Reduce</li>
                <li>Opject Map() => có tính chất lặp qua nó, có thể đặt `key` là bất cứ kiểu dl gì trong js</li>
                <li>Object.assign()</li>
                <li><code>window.dispatch = dispatch</code>: đặt function `dispatch` thành global (có thể sử dụng bất cứ đâu)</li>
            </ul>

            <fieldset>
                <legend>REDUX - Build UI</legend>
                <div id="redux-root"></div>
            </fieldset>
            

        </div>


        <h2>14. Code ứng dụng Todo List</h2>
        <div>
            <ul>
                <li><a href="https://github.com/Klerith/TODO-CSS-Template" target="_blank">github: TODO-CSS-Template</a></li>
            </ul>

            <h3><a href="./bai14_redux_todosApp/index.html" target="_blank">Bai 14 - Todo App</a></h3>
        </div>







    </div>
    <!-- <script src="./index.js"></script> -->
    <!-- <script src="./index2.js"></script> -->
    <!-- <script src="./index3.js"></script> -->
    <!-- <script src="./index4.js"></script> -->
    <!-- <script src="./index5.js"></script> -->

    <!-- redux (bài 12) -->
    <!-- <script type="module" src="./redux.js"></script> -->
    
    <!-- redux (bài 13) -->
    <script type="module" src="./bai13_redux/redux_script.js"></script>

</body>
</html>